use std::str::FromStr;

use crate::ast::{Expr, Atom, BinOp, Types};
use crate::lexer::LexicalError;
use crate::tokens::Token;

use num_bigint::BigInt;
use num_traits::ToPrimitive;

grammar;

// The top layers

pub Expr: Box<Expr> = {
    "\\" <Ident> ":" <Type> "->" <Expr> => Box::new(Expr::Abs(<>)),
    "if" <AppExpr> "then" <Expr> "else" <Expr> => Box::new(Expr::If(<>)),
    "let" <Ident> "=" <Expr> "in" <Expr> => Box::new(Expr::Let(<>)),
    AppExpr
};

AppExpr: Box<Expr> = {
    AppExpr Term => Box::new(Expr::App(<>)),
    CompareOpExpr
};

// BinOps

// Defining a macro, so that it is easier to create precedence
Tier<Op, NextTier>: Box<Expr> = {
    Tier<Op, NextTier> Op NextTier => Box::new(Expr::BinOp(<>)),
    NextTier
};

CompareOpExpr = Tier<CompareOp, AddSubOpExpr>;
AddSubOpExpr = Tier<AddSubOp, MulDivOpExpr>;
MulDivOpExpr = Tier<MulDivOp, Term>;

CompareOp: BinOp = {
    "==" => BinOp::Eq,
    "!=" => BinOp::Ne,
    "<=" => BinOp::Le,
    ">=" => BinOp::Ge,
    "<" => BinOp::Less,
    ">" => BinOp::Greater,
};

AddSubOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};

MulDivOp: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
};

// Bottom layers

pub Term: Box<Expr> = {
    Literal => Box::new(Expr::Const(<>)),
    Ident => Box::new(Expr::Const(<>)),
    "(" <Expr> ")"
}

// The most bottom layers

Type: Types = {
    <t1: Type> "->" <t2: NextType> => Types::Abs(Box::new(t1), Box::new(t2)),
    NextType,
}

NextType: Types = {
    "unit" => Types::Unit,
    "int" => Types::Int,
    "(" <Type> ")"
}

Literal: Atom = {
    LitUnit => Atom::Unit,
    LitInt => Atom::Num(<>),
};

Ident: Atom = {
    Identifier => Atom::Var(<>),
};

// Hook external lexer:

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        // Data
        Identifier => Token::Name(<String>),
        LitUnit => Token::LitUnit,
        LitInt => Token::LitInt(<BigInt>),

        // Keywords
        "if" => Token::If,
        "then" => Token::Then,
        "else" => Token::Else,
        "let" => Token::Let,
        "in" => Token::In,
        "unit" => Token::Unit,
        "int" => Token::Int,
        "foldp" => Token::Foldp,
        "async" => Token::Async,

        // Symbols
        "\\" => Token::BSlash,
        ":" => Token::Colon,
        "," => Token::Comma,
        "=" => Token::Eq,
        "->" => Token::LArrow,
        ">" => Token::Great,
        "<" => Token::Less,
        "==" => Token::EqEqual,
        ">=" => Token::Geq,
        "<=" => Token::Leq,
        "!=" => Token::Ne,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Mul,
        "/" => Token::Div,

        // Delimiters
        "(" => Token::LParen,
        ")" => Token::RParen,
    }
}
