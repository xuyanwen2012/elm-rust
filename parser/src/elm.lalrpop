use std::str::FromStr;

use crate::ast::{Expr, Atom, BinOp};

grammar;

// Top

pub Expr: Box<Expr> = {
    "\\" <Ident+> "->" <Expr> => Box::new(Expr::Abs(<>)),
    "if" <AppExpr> "then" <Expr> "else" <Expr> => Box::new(Expr::If(<>)),
    "let" <decls:Comma<Declaration>> "in" <e:Expr> => Box::new(Expr::Let(decls, e)),
    AppExpr
};

Declaration: (String, Box<Expr>) = {
    <x:Ident> "=" <e:Expr> => (x, e)
};

AppExpr: Box<Expr> = {
    AppExpr BinOpAExpr => Box::new(Expr::App(<>)),
    BinOpAExpr
};

// BinOps

// Defining a macro, so that it is easier to create precedence
Tier<Op, NextTier>: Box<Expr> = {
    Tier<Op, NextTier> Op NextTier => Box::new(Expr::BinOp(<>)),
    NextTier
};

BinOpAExpr = Tier<CompareOp, BinOpBExpr>;
BinOpBExpr = Tier<AddSubOp, BinOpCExpr>;
BinOpCExpr = Tier<MulDivOp, Term>;

CompareOp: BinOp = {
    "==" => BinOp::Eq,
    "!=" => BinOp::Ne,
    "<=" => BinOp::Le,
    ">=" => BinOp::Ge,
    "<" => BinOp::Less,
    ">" => BinOp::Greater,
};

AddSubOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};

MulDivOp: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
};

// The most bottom terms

Term: Box<Expr> = {
    Const => Box::new(Expr::Const(<>)),
    "(" <Expr> ")"
};

Const: Atom = {
    "()" => Atom::Unit,
    Num => Atom::Num(<>),
    Ident => Atom::Var(<>),
};

// Helpers

#[inline]
Comma<T>: Vec<T> = {
    <items: (<T> ",")*> <last: T?> => {
        let mut items = items;
        items.extend(last);
        items
    }
};

#[inline]
OneOrMore<T>: Vec<T> = {
    <i1: T> <i2:("," T)*> => {
        let mut items = vec![i1];
        items.extend(i2.into_iter().map(|e| e.1));
        items
    }
};

// Literals

Ident: String = {
    r"[A-Za-z][A-Za-z0-9_]*" => <>.to_string()
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};

// Some keywords

//LiftN: u8 = {
////    r"lift[1-5]" => i32::from_str(<>.chars().last().unwrap()).unwrap()
//};
