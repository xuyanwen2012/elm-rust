use std::str::FromStr;

use crate::ast::{Expr, Atom, BinOp, Types};
use crate::lexer::LexicalError;
use crate::tokens::Token;

use num_bigint::BigInt;
use num_traits::ToPrimitive;

grammar;

// The top layers

pub Expr: Box<Expr> = {
    "\\" <Ident> ":" <Type> "->" <Expr> => Box::new(Expr::Abs(<>)),
    Term
};

pub Term: Box<Expr> = {
    Literal => Box::new(Expr::Const(<>)),
    Ident => Box::new(Expr::Const(<>)),
    "(" <Expr> ")"
}

// The most bottom layers

Type: Types = {
    <t1: Type> "->" <t2: NextType> => Types::Abs(Box::new(t1), Box::new(t2)),
    NextType,
}

NextType: Types = {
    "unit" => Types::Unit,
    "int" => Types::Int,
    "(" <Type> ")"
}

Literal: Atom = {
    LitUnit => Atom::Unit,
    LitInt => Atom::Num(<>),
};

Ident: Atom = {
    Identifier => Atom::Var(<>),
};

// Hook external lexer:

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        // Data
        Identifier => Token::Name(<String>),
        LitUnit => Token::LitUnit,
        LitInt => Token::LitInt(<BigInt>),

        // Keywords
        "if" => Token::If,
        "then" => Token::Then,
        "else" => Token::Else,
        "let" => Token::Let,
        "in" => Token::In,
        "unit" => Token::Unit,
        "int" => Token::Int,
        "foldp" => Token::Foldp,
        "async" => Token::Async,

        // Symbols
        "\\" => Token::BSlash,
        ":" => Token::Colon,
        "," => Token::Comma,
        "=" => Token::Eq,
        "->" => Token::LArrow,

        // Delimiters
        "(" => Token::LParen,
        ")" => Token::RParen,
    }
}
