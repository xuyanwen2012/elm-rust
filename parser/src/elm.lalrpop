use std::str::FromStr;

use crate::ast::{Expr, Atom, BinOp};
use crate::lexer::LexicalError;
use crate::tokens::Token;

use num_bigint::BigInt;
use num_traits::ToPrimitive;

grammar;

// The top layers

pub Expr: Box<Expr> = {
    Literal => Box::new(Expr::Const(<>)),
    Ident => Box::new(Expr::Const(<>)),
};

// The most bottom layers

Literal: Atom = {
    LitInt => Atom::Num(<>),
    LitUnit =>  Atom::Unit,
};

Ident: Atom = {
    Identifier => Atom::Var(<>),
};

// Hook external lexer:

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        // Data
        Identifier => Token::Name(<String>),
        LitUnit => Token::LitUnit,
        LitInt => Token::LitInt(<BigInt>),

        // Keywords
        "if" => Token::If,
        "then" => Token::Then,
        "else" => Token::Else,
        "let" => Token::Let,
        "in" => Token::In,
        "unit" => Token::Unit,
        "int" => Token::Int,
        "foldp" => Token::Foldp,
        "async" => Token::Async,

        // Symbols
        "\\" => Token::BSlash,
        ":" => Token::Colon,
        "," => Token::Comma,
        "=" => Token::Eq,
        "->" => Token::LArrow,

        // Delimiters
        "(" => Token::LParen,
        ")" => Token::RParen,
    }
}
